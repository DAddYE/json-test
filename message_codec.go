// ************************************************************
// DO NOT EDIT.
// THIS FILE IS AUTO-GENERATED BY codecgen.
// ************************************************************

package json_bench

import (
	"errors"
	"fmt"
	"reflect"
	"runtime"

	codec1978 "github.com/ugorji/go/codec"
)

const (
	codecSelferC_UTF87923         = 1
	codecSelferC_RAW7923          = 0
	codecSelverValueTypeArray7923 = 10
	codecSelverValueTypeMap7923   = 9
)

var (
	codecSelferBitsize7923                         = uint8(reflect.TypeOf(uint(0)).Bits())
	codecSelferOnlyMapOrArrayEncodeToStructErr7923 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer7923 struct{}

func init() {
	if codec1978.GenVersion != 2 {
		_, file, _, _ := runtime.Caller(0)
		err := fmt.Errorf("codecgen version mismatch: current: %v, need %v. Re-generate file: %v",
			2, codec1978.GenVersion, file)
		panic(err)
	}
	if false { // reference the types, but skip this branch at build/run time
	}
}

func (x Status) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7923
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.EncodeInt(int64(x))
}

func (x *Status) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7923
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	*((*int32)(x)) = int32(r.DecodeInt(32))
}

func (x *Message) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7923
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep1 := !z.EncBinary()
		const yyr1 bool = false
		var yyq1 [2]bool
		if yyr1 || z.EncBasicHandle().StructToArray {
			r.EncodeArrayStart(2)
		} else {
			var yynn1 int = 2
			for _, b := range yyq1 {
				if b {
					yynn1++
				}
			}
			r.EncodeMapStart(yynn1)
		}
		if yyr1 || z.EncBasicHandle().StructToArray {
			r.EncodeString(codecSelferC_UTF87923, string(x.Body))
		} else {
			r.EncodeString(codecSelferC_UTF87923, string("Body"))
			if yysep1 {
				r.EncodeMapKVSeparator()
			}
			r.EncodeString(codecSelferC_UTF87923, string(x.Body))
		}
		if yyr1 || z.EncBasicHandle().StructToArray {
			if yysep1 {
				r.EncodeArrayEntrySeparator()
			}
			x.Status.CodecEncodeSelf(e)
		} else {
			if yysep1 {
				r.EncodeMapEntrySeparator()
			}
			r.EncodeString(codecSelferC_UTF87923, string("Status"))
			if yysep1 {
				r.EncodeMapKVSeparator()
			}
			x.Status.CodecEncodeSelf(e)
		}
		if yysep1 {
			if yyr1 || z.EncBasicHandle().StructToArray {
				r.EncodeArrayEnd()
			} else {
				r.EncodeMapEnd()
			}
		}
	}
}

func (x *Message) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7923
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	if r.IsContainerType(codecSelverValueTypeMap7923) {
		yyl4 := r.ReadMapStart()
		if yyl4 == 0 {
			r.ReadMapEnd()
		} else {
			x.codecDecodeSelfFromMap(yyl4, d)
		}
	} else if r.IsContainerType(codecSelverValueTypeArray7923) {
		yyl4 := r.ReadArrayStart()
		if yyl4 == 0 {
			r.ReadArrayEnd()
		} else {
			x.codecDecodeSelfFromArray(yyl4, d)
		}
	} else {
		panic(codecSelferOnlyMapOrArrayEncodeToStructErr7923)
	}
}

func (x *Message) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7923
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yys5Slc = z.DecScratchBuffer() // default slice to decode into
	_ = yys5Slc
	var yyhl5 bool = l >= 0
	for yyj5 := 0; ; yyj5++ {
		if yyhl5 {
			if yyj5 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
			if yyj5 > 0 {
				r.ReadMapEntrySeparator()
			}
		}
		yys5Slc = r.DecodeBytes(yys5Slc, true, true)
		yys5 := string(yys5Slc)
		if !yyhl5 {
			r.ReadMapKVSeparator()
		}
		switch yys5 {
		case "Body":
			if r.TryDecodeAsNil() {
				x.Body = ""
			} else {
				x.Body = r.DecodeString()
			}
		case "Status":
			if r.TryDecodeAsNil() {
				x.Status = 0
			} else {
				x.Status = Status(r.DecodeInt(32))
			}
		default:
			z.DecStructFieldNotFound(-1, yys5)
		} // end switch yys5
	} // end for yyj5
	if !yyhl5 {
		r.ReadMapEnd()
	}
}

func (x *Message) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7923
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	if r.TryDecodeAsNil() {
		x.Body = ""
	} else {
		x.Body = r.DecodeString()
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = r.CheckBreak()
	}
	if yyb8 {
		r.ReadArrayEnd()
		return
	}
	r.ReadArrayEntrySeparator()
	if r.TryDecodeAsNil() {
		x.Status = 0
	} else {
		x.Status = Status(r.DecodeInt(32))
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = r.CheckBreak()
		}
		if yyb8 {
			break
		}
		if yyj8 > 1 {
			r.ReadArrayEntrySeparator()
		}
		z.DecStructFieldNotFound(yyj8-1, "")
	}
	r.ReadArrayEnd()
}
